<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zarraz Cube App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="fixed inset-0 flex flex-col items-center justify-center p-4 z-10">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-center mb-4 md:mb-6 leading-tight">Zarraz Cube</h1>
        <p class="text-sm md:text-base text-center text-gray-400 mb-8 max-w-lg" id="statusMessage">
            Loading...
        </p>

        <!-- Container for messages -->
        <div id="messageBox" class="bg-blue-800 bg-opacity-30 border-l-4 border-blue-500 text-blue-200 p-4 rounded-lg hidden mb-6 transition-all duration-300 w-full max-w-md" role="alert">
            <p id="messageText" class="font-medium"></p>
        </div>

        <!-- Authentication Form - Initially hidden -->
        <div id="authForm" class="w-full max-w-md flex-col gap-4 p-6 bg-gray-800 rounded-xl shadow-lg hidden">
            <input type="email" id="emailInput" placeholder="Email" class="p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
            <input type="password" id="passwordInput" placeholder="Password" class="p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
            <div class="flex flex-col sm:flex-row gap-3">
                <button id="signUpButton" class="w-full bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-indigo-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    Sign Up
                </button>
                <button id="signInButton" class="w-full bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500">
                    Sign In
                </button>
            </div>
        </div>

        <!-- App Controls - Initially hidden -->
        <div id="appControls" class="w-full max-w-md flex-col items-center gap-4 hidden">
            <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 w-full justify-center">
                <button id="saveButton" class="w-full sm:w-1/2 bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-indigo-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    Save Cube State
                </button>
                <button id="loadButton" class="w-full sm:w-1/2 bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-green-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-green-500">
                    Load Cube State
                </button>
            </div>
            <button id="signOutButton" class="mt-4 w-full bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-red-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-red-500">
                Sign Out
            </button>
        </div>
    </div>

    <!-- The Canvas for the 3D cube -->
    <canvas id="canvas"></canvas>

    <script type="module">
        const firebaseEnabled = typeof __firebase_config !== 'undefined';
        
        let firebaseConfig = {};
        if (firebaseEnabled) {
            firebaseConfig = JSON.parse(__firebase_config);
        }
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Global variables for Firebase services and user ID
        let app, db, auth, userId = null;
        let firebaseModulesLoaded = false;

        // UI elements
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const signOutButton = document.getElementById('signOutButton');
        const signUpButton = document.getElementById('signUpButton');
        const signInButton = document.getElementById('signInButton');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const authForm = document.getElementById('authForm');
        const appControls = document.getElementById('appControls');
        const canvas = document.getElementById('canvas');
        const statusMessage = document.getElementById('statusMessage');

        // --- Three.js Setup ---
        let scene, camera, renderer, cube;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            camera.position.z = 2;

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshNormalMaterial();
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            document.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition.x = e.clientX; previousMousePosition.y = e.clientY; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                cube.rotation.y += deltaMove.x * 0.005;
                cube.rotation.x += deltaMove.y * 0.005;
                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });
            document.addEventListener('touchstart', (e) => { isDragging = true; const touch = e.touches[0]; previousMousePosition.x = touch.clientX; previousMousePosition.y = touch.clientY; });
            document.addEventListener('touchend', () => { isDragging = false; });
            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const deltaMove = { x: touch.clientX - previousMousePosition.x, y: touch.clientY - previousMousePosition.y };
                cube.rotation.y += deltaMove.x * 0.005;
                cube.rotation.x += deltaMove.y * 0.005;
                previousMousePosition.x = touch.clientX;
                previousMousePosition.y = touch.clientY;
            });

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
        }

        // --- Firebase Integration and Authentication Logic ---
        function showMessage(text, isError = false) {
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
            if (isError) {
                messageBox.classList.remove('bg-blue-800', 'bg-opacity-30', 'border-blue-500', 'text-blue-200');
                messageBox.classList.add('bg-red-800', 'bg-opacity-30', 'border-red-500', 'text-red-200');
            } else {
                messageBox.classList.remove('bg-red-800', 'bg-opacity-30', 'border-red-500', 'text-red-200');
                messageBox.classList.add('bg-blue-800', 'bg-opacity-30', 'border-blue-500', 'text-blue-200');
            }
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        async function initFirebase() {
            if (!firebaseEnabled) {
                statusMessage.textContent = "Authentication is disabled because Firebase configuration is not available.";
                return;
            }
            
            // Dynamically import Firebase modules
            const firebaseAppModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js");
            const firebaseAuthModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js");
            const firestoreModule = await import("https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js");

            // Assign imported functions to be used globally
            const { initializeApp } = firebaseAppModule;
            const { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken } = firebaseAuthModule;
            const { getFirestore, doc, getDoc, setDoc } = firestoreModule;

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        authForm.classList.add('hidden');
                        appControls.classList.remove('hidden');
                        showMessage(`Welcome back, ${user.email}!`);
                        statusMessage.textContent = "You are now logged in and can save/load the shared cube state.";
                    } else {
                        userId = null;
                        authForm.classList.remove('hidden');
                        appControls.classList.add('hidden');
                        showMessage("Please sign in or sign up.", false);
                        statusMessage.textContent = "Create an account or log in to save and load the shared cube state.";
                    }
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                }
                
                // Set up event listeners after Firebase is initialized and ready
                signUpButton.addEventListener('click', signUp);
                signInButton.addEventListener('click', signIn);
                signOutButton.addEventListener('click', signOutUser);
                saveButton.addEventListener('click', saveCubeState);
                loadButton.addEventListener('click', loadCubeState);
            
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showMessage(`Error initializing Firebase: ${error.message}`, true);
                statusMessage.textContent = "An error occurred. Firebase features are disabled.";
            }

            // --- User Authentication Functions (now nested to access auth and other variables) ---
            async function signUp() {
                const email = emailInput.value;
                const password = passwordInput.value;
                if (!email || !password) {
                    showMessage("Please enter both email and password.", true);
                    return;
                }
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showMessage("Sign up successful! You are now logged in.");
                } catch (error) {
                    console.error("Sign up error:", error);
                    showMessage(`Sign up failed: ${error.message}`, true);
                }
            }

            async function signIn() {
                const email = emailInput.value;
                const password = passwordInput.value;
                if (!email || !password) {
                    showMessage("Please enter both email and password.", true);
                    return;
                }
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage("Sign in successful!");
                } catch (error) {
                    console.error("Sign in error:", error);
                    showMessage(`Sign in failed: ${error.message}`, true);
                }
            }

            async function signOutUser() {
                try {
                    await signOut(auth);
                    showMessage("You have been signed out.");
                } catch (error) {
                    console.error("Sign out error:", error);
                    showMessage(`Sign out failed: ${error.message}`, true);
                }
            }

            async function saveCubeState() {
                if (!userId) {
                    showMessage("You must be logged in to save the cube state.", true);
                    return;
                }

                const docId = 'zarraz-state';
                const path = `artifacts/${appId}/public/cube-state/${docId}`;
                const docRef = doc(db, path);

                try {
                    const rotation = {
                        x: cube.rotation.x,
                        y: cube.rotation.y,
                        z: cube.rotation.z
                    };

                    await setDoc(docRef, { 
                        rotation, 
                        lastUpdated: new Date() 
                    });
                    
                    console.log(`Cube state saved to public space.`);
                    showMessage("Cube state saved to public space!");
                } catch (e) {
                    console.error("Error saving document: ", e);
                    showMessage(`Error saving state: ${e.message}`, true);
                }
            }

            async function loadCubeState() {
                if (!userId) {
                    showMessage("You must be logged in to load the cube state.", true);
                    return;
                }

                const docId = 'zarraz-state';
                const path = `artifacts/${appId}/public/cube-state/${docId}`;
                const docRef = doc(db, path);

                try {
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        const rotation = data.rotation;
                        
                        cube.rotation.x = rotation.x;
                        cube.rotation.y = rotation.y;
                        cube.rotation.z = rotation.z;

                        console.log(`Cube state loaded from public space.`);
                        showMessage("Cube state loaded from public space!");
                    } else {
                        showMessage("No saved cube state found in public space.", true);
                        console.log("No saved state found!");
                    }
                } catch (e) {
                    console.error("Error loading document: ", e);
                    showMessage(`Error loading state: ${e.message}`, true);
                }
            }
        }
        
        // This is the new, primary change: The cube initialization runs immediately.
        initThreeJS();
        
        // Then, after the cube is loaded, we proceed with Firebase initialization.
        initFirebase();
    </script>
</body>
</html>
